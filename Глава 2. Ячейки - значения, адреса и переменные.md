# Всё о "ячейках" - значениях, адресах и переменных
Как мы отметили в первой главе, 
> первое и основное требование к "железу", зафиксированное в языке Си - это наличие ячеек оперативной памяти разрядности по меньшей мере 8 бит. Можно больше, можно даже некратное 8 число(!), единственное что должно быть, что ячейка хранит не меньше 256 различных чисел и использует для этого двоичную систему счисления

Ячейка физически может быть расположена либо в оперативной памяти, либо в регистре процессора. Если значение находится в процессоре, то оно может быть
1. храниться там в одном из регистров
2. быть получено как промежуточный результат

Язык Си также предполагает, что ячейки могут содержать значения, которые будут содержать номера других ячеек - ячейки могут ссылаться одна на другую. Такие значения называются **адресами**.

Это верно во всех случаях, кроме п.2 - язык Си в угоду переносимости не допускает получения адреса некоторого значения, полученного посреди вычислений. 

В языке Си есть переменные - это именованные ячейки некоторой разрядности (не обязательно ту самую, что 8бит или больше, если разработчики компилятора предусмотрели, то можно взять две и больше "элементарных" ячеек и воспринимать значения в них как запись одного значения).
Также, *в отличие от ассемблера*, С "помечает", какое значение будет храниться в ячейках. Эта пометка называется **типом**.

## Типы данных
Типов данных в С сравнительно много, но мы выделим базовые:
* ```char``` - тип, соответствующий разрядности минимальной "ячейки" компьютера в C (но разрядностью не меньше, чем 8 бит. Впрочем, меньше 8 бит - это была большая редкость даже для времен зарождения C). Гарантируется, что может хранить не меньше 256 значений, но не гарантируется, в каких пределах. Как правило, разработчики компиляторов выбирают либо от -128 до +127, либо от 0 до 255. Именно поэтому следует осторожно относиться к действиям над числами больше 127 или меньше 0. Впрочем, **почти всегда** char используется не для хранения чисел (для этого рекомендуются signed или unsigned char), а для хранения символов в кодировке ANSI. В этом случае гарантируется постоянство символов, кодируемых от 0 до 127. 
* ```unsigned char``` - тип, гарантирующий минимальный объем занимаемой памяти и место на значение от 0 до 255
* ```signed char``` - аналогично ```unsigned```, но от -128 до +127
* ```short int``` - синоним ```signed short int```, и по стандарту даст на значение не меньше одного ```char```'а **(но не гарантируется, что даст больше!)**
* ```unsigned short int``` - тот же ```short int```, но беззнаковый
* ```int``` - синоним ```signed int``` и по стандарту даст не меньше ```char```'ов, чем ```short int``` **(но не гарантируется, что даст больше!)**
* ```unsigned int``` - тот же ```int```, но беззнаковый
* ```long int``` - та же ситуация: даст на хранение значения не меньше ```char```'ов, чем ```int```
* ```long long int```, ```unsigned long int```, ```unsigned long long int```  - (угадаем??)

Определить, сколько ```char```'ов занимает хранение значения того или иного типа, можно, вызвав ```sizeof(long int)```

Весь кошмар выше можно описать проще одним составным неравенством:
1 = sizeof(char) = sizeof(unsigned char) = sizeof(signed char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)

И да, слово int можно убирать, если оно не единственное. Также знаковые и беззнаковые типы, конечно, имеют одинаковую разрядность.

Чтобы узнать разрядность ```char```'а в битах, мы можем воспользоваться заложенным в стандарте макросом (считай константой): ```CHAR_BIT```.

#### Три слова о логическом типе данных
*Булевского типа в чистом языке C **нет*** (но он есть в C++). Это объясняется тем, о чем я твержу всю эту главу - в C не бывает типа разрядностью меньше чем ```char```. Если нужно логическое значение (а оно нужно для операторов if, while, ...), то любое целое, кроме 0, интерпретируется как истина, а 0 - как ложь.

#### Пара слов о типе данных с плавающей точкой
<!-- Он менее продуман и менее заморочен, вследствие того что до конца 90ых далеко не каждый компьютер был оснащен сопроцессором чисел с плавающей запятой, а сами эти операции в сотни раз дольше, чем операции над целыми числами. Стандартный набор включает в себя ```float```, ```double``` и ```long double``` для разной точности. -->

## Указатели - переменные, содержащие адреса

Также имена переменных (**не** сами типы!) могут помечаться звездочкой, вот так:
```C
int value, *address;
```
```address``` будет хранить не само целое число, а будет **указателем** на переменную целого типа - то есть будет хранить тот самый адрес. Например, она может хранить указатель ```value```. Для этого воспользуемся оператором ```&``` (ссылка - получить адрес переменной):
```C
int value, *address;
address = &value;
```
Стоит отдельно заметить, что использовать & к выражениям мы не можем по причине, указанной в самом начале - получить адрес можно только в том случае, если это переменная - то есть именованная ячейка, которая может храниться в оперативной памяти либо регистрах, но никак не промежуточные никуда не записанные вычисления.

Обратное действие - разыменовать указатель - можно применить не только к переменным, но и к любому значению, лишь бы по адресу было что-то (иначе это может грозить падением программы).

Попробуем умножить нашу ```value``` на 2 не упоминая саму ```value```:
```C
int value, *address;
value = 42;
address = &value;
*address += *address;
```
### Переменные сами себя не инициализуют!
И да, ```value=42``` обязателен. И даже если был бы ```value=0``` всё равно это было бы обязательно. Дело в том, что как правило C, в отличие от большинства других языков, не записывает в ячейки никаких значений по умолчанию. Какие ~~объедки~~ мусорные данные там остались с прошлого раза, те и подаст, ~~приятного аппетита. Зато быстро, прямо как в фастфуде.~~ И да, это тоже сделано ради производительности. Вся ответственность лежит на программисте, взамен - полный контроль над происходящим.

Особенно чётко указанный это надо помнить, когда создаёшь переменную для счётчика по циклу.

## Наша первая программа
Я уже отмечал, что пишу данную "методичку" *совсем* не для тех, кто впервые решил показать компьютеру, кто тут в доме хозяин, а кто исполнитель. Эта методичка для тех, кто "боится" языка Си, хотя знаком (возможнно, посредственно) с другими языками программирования.

... Именно поэтому в ней первая программа будет не Hello world, а программа несколько иного рода.

Но перед тем, как мы начнём, прокомментирую некоторые (пока) несущественные строки данной программы.
```C
#include <stdio.h> /*подключаемый заголовочный файл, можно сказать что "библиотека". нужна для вывода информации*/
int main(void) { /* именно то, что ограничено int main(void) { и }, и будет исполняться */
  /*тут будет наш код*/
  return 0; /* историческое соглашение, пришедшее из чуть более поздних юниксов - если программа завершилась успешно, то она (как некая функция) возвращает значение 0. Иначе - код ошибки. */
}
```

Теперь *на месте "тут будет наш код"* напишем то, ради чего мы старались. Напишем нашу прошлую программу и дополним некоторой полезной информацией:
```C
int value, *address;
address = &value;

scanf("%d", &value); /*нужно для чтения целого значения. и да, поскольку читаем мы в переменную по некоторому адресу, то нужна ссылка */
/*и да, scanf("%d", address); тоже сработает в данном случае на ура*/

*address += *address;

printf("value=%d\n", value);
printf("address of value variable=%p\n", &value);
printf("address variable=%p\n", address);
printf("address of address variable=%p\n", &address);
```
И мы получили вывод программы в ответ на ввод числа 3:
```
value=6
address of value variable=0x7fff74c9842c
address variable=0x7fff74c9842c
address of address variable=0x7fff74c98430
```
Как видим, значение основной переменной увеличилось в два раза (от сложения с самой собой), а значение указателя равно адресу основной переменной. У указателя также есть адрес, и соответственно на него тоже можно сослаться.
