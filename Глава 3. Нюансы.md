# Нюансы, связанные с переменными и/или типами данных
## область видимости
Область видимости - это область, в пределах которой переменная будет определена.
Область видимости ограничивается одним блоком кода, и начинается с оператора определения.

```
int iAmGlobal; /* переменная iAmGlobal может быть вызвана откуда угодно, так как не вложена ни в один блок кода */

int f(int x){ /* x определена как параметр функции, и она здесь есть всю функцию*/
  int isOdd = x%2; /*isOdd - начало жизни*/
  return x+isOdd; 
} /*isOdd - конец жизни после закрывающей } */

```
Строго говоря, ради локальных переменных можно даже специально выделять блоки кода, хотя _до_ них нет ни while, ни for, ни if, ... :
```
{
  int i;
  for (i = 0; i<N; ++i) { /*кстати, в C89 НЕЛЬЗЯ определять локальные переменные прямо в заголовке, поэтому тут этот трюк уместен*/
    printf("%d", i);
  }
} /*здесь кончилась жизнь счётчика i*/
```
В прошлом примере мы определили переменную локальный счётчик, а потом ~~использовали и выбросили~~ ограничили область видимости, чтобы этот ```i``` не подсунул себя и своё последнее значение (N), если мы вдруг что-то попутаем, и забудем определить и инициализировать новую переменную с этим же именем в следующий раз.

## пользовательские перечислимые типы данных - enum

Мы можем определять свои пользовательские типы данных и значения, например, так:
```c
enum DayType {
  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
};
```
Капс здесь исключительно часть форматирования.
И да, кстати, не забываем про точку с запятой после ```enum```. И после этого определения можно присваивать переменным этого типа значения этого типа:
```
enum DayType today = FRIDAY;
today = SATURDAY;
```

И внимание(!) **нельзя** делать так: ```today += 1;```, так: ```today++;``` или так: ```today = today + 1;```.

Язык Си на этот счёт даже не пикнет, а Вы можете очень сильно обмануться, и причина здесь в том, что на самом деле с точки зрения компьютера не создаётся никакого нового типа - просто используется обычное целое число, и различным значениям в соответствие ставятся числа. Разумеется, в случае с днями недели всё хорошо, но как насчёт такого примера?
```
enum CoinType {
  ONE_RUBLE, TWO_RUBLES, FIVE_RUBLES, TEN_RUBLES
};
```

Уже чувствуете, что может произойти, да? Кстати, каждому именному значению можно поставить в соответствие число, но положение это не спасёт, всё будет даже ещё хуже, т.к. вы выйдете за пределы типа, который сами же определили.

Также возможен абсурд, например, такого характера:
```c
enum DayType {
  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
};
enum CoinType {
  ONE_RUBLE, TWO_RUBLES, FIVE_RUBLES, TEN_RUBLES
};
enum DayType x = MONDAY;
enum CoinType y = ONE_RUBLE;
if (x == y) {
  printf("equal!");
}
```
Мы сравнили ~~жидкое с мягким~~ монетки с днями недели, и да, этот код скомпилируется в C без ошибок и без ошибок же выполнится, и покажет, что один рубль - это понедельник.


С другой стороны, пользовательские типы данных, если следить за соответствием типов, позволяют отвлечься от представления информации в том или ином виде.

# Типы данных стандарта C99
Также есть типы данных, определенные в стандарте C 99ого года, а не "исходном" стандарте C89 или он же C90. Они не всегда доступны (бывают разные компиляторы и архитектуры самой разной степени ~~задрипанности~~ уровня предлагаемой поддержки), плюс эти раcширения очень не любят некоторые консервативно настроенные преподаватели вузов, так что подумайте дважды, прежде чем пользоваться этими возможностями. 
## Числа с гарантией
Они гарантируют (а не подразумевают), что есть типы данных для хранения по меньшей мере 8, 16, 32 и 64битных чисел, в двух исполнениях: наименьшей занимаемой памятью и наибольшей скоростью обработки. Почитать о них подробнее можно в интернете [https://ru.wikipedia.org/wiki/Stdint.h].
## ```size_t``` и ```ptrdiff_t```
```size_t``` позволяет описать размер участка памяти в ```char```'ах, который вообще может быть доступен программе. Именно этот тип рекомендуется для записи размера участков памяти.
```ptfdiff_t``` позволяет описать разницу между любыми двумя доступными программе адресами. Таким образом, любая разность между двумя указателями на самом деле имеет тип ```ptrdiff_t```.

## stdbool.h

И да, в версии 99ого завезли ```bool```. На самом деле это обычный ```char``` (в чем можно убедиться взглянув на вывод ```printf("boolsize=%d", sizeof(bool);``` ), но с одной приятной "фишкой": после присвоения нового ненулевого значения оно автоматически откатывается к 1. Защиты от переполнения ещё до присвоения значения переменной, разумеется, нет.
Поскольку -1 сводится к 1 и 2 тоже сводится к 1, то вычитание из "булевской" переменной единицы (декремент) даст нам смену значения, а инкремент (добавление) оставит единицу на месте, если она там была (и добавит её, если не было).

Нельзя не подчеркнуть, что хотя данная опция выглядит заманчиво, она сильно контрастирует с идеями "переносимого ассемблера" и "продвинутого контроля над программой". Впрочем, если говорить начистоту, сейчас даже ассемблер не может предложить такой возможности - ведь на самом деле в той же x86 исполняется не этот ассемблерный код, а т.н. "микрокод". НО это мелочи.
